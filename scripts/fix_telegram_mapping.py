#!/usr/bin/env python3
"""
Script to fix Telegram mapping by examining actual chat contents
"""

import os
import re
from pathlib import Path
import sqlite3


def get_chat_names():
    """Get actual chat names from all chat directories"""
    chat_dir = Path("data/telegram/DataExport_2025-08-19/chats")
    chat_names = {}

    for chat_path in sorted(chat_dir.glob("chat_*")):
        if chat_path.is_dir():
            chat_id = chat_path.name
            messages_file = chat_path / "messages.html"

            if messages_file.exists():
                try:
                    with open(messages_file, "r", encoding="utf-8") as f:
                        content = f.read()

                    # Extract chat name from page header
                    match = re.search(
                        r'<div class="text bold">\s*(.*?)\s*</div>', content
                    )
                    if match:
                        chat_name = match.group(1).strip()
                        chat_names[chat_id] = chat_name
                    else:
                        chat_names[chat_id] = "Unknown"

                except Exception as e:
                    print(f"Error reading {chat_id}: {e}")
                    chat_names[chat_id] = "Error"

    return chat_names


def check_internal_team_activity(chat_id):
    """Check if a chat has messages from internal team members"""
    messages_file = Path(
        f"data/telegram/DataExport_2025-08-19/chats/{chat_id}/messages.html"
    )

    if not messages_file.exists():
        return False, 0

    try:
        with open(messages_file, "r", encoding="utf-8") as f:
            content = f.read()

        # Look for messages from internal team
        internal_team = ["Aki", "Addie", "Mayank", "Amy", "Kadeem Clarke", "akibalogh"]
        internal_messages = 0

        for member in internal_team:
            # Count messages from this team member
            pattern = rf'<div class="from_name">\s*(.*?)\s*</div>'
            all_from_names = re.findall(pattern, content)

            for name in all_from_names:
                if member.lower() in name.lower():
                    internal_messages += 1
                    break  # Count each member only once per chat

        return internal_messages > 0, internal_messages

    except Exception as e:
        print(f"Error checking {chat_id}: {e}")
        return False, 0


def find_customer_conversations():
    """Find chats that are actual customer conversations"""
    chat_names = get_chat_names()
    customer_chats = {}

    print("üîç Analyzing Telegram chats for customer conversations...")
    print("=" * 60)

    for chat_id, chat_name in sorted(chat_names.items()):
        # Skip internal BitSafe chats (but allow customer chats that mention BitSafe)
        if any(
            internal in chat_name.lower()
            for internal in [
                "bitsafe company",
                "bitsafe product",
                "bitsafe bd",
                "internal bitsafe",
            ]
        ):
            print(f"üö´ {chat_id}: {chat_name} (Internal BitSafe)")
            continue

        # Check for internal team activity
        has_activity, message_count = check_internal_team_activity(chat_id)

        if has_activity:
            print(f"‚úÖ {chat_id}: {chat_name} ({message_count} internal messages)")
            customer_chats[chat_id] = {
                "name": chat_name,
                "internal_messages": message_count,
            }
        else:
            print(f"‚ùå {chat_id}: {chat_name} (No internal activity)")

    return customer_chats


def create_correct_mapping(customer_chats):
    """Create a correct mapping file"""
    mapping_content = """# Corrected Telegram to Company Mapping
# Generated by examining actual chat contents

"""

    company_count = 0
    for chat_id, info in customer_chats.items():
        # Extract company name from chat name
        chat_name = info["name"]

        # Skip individual people and internal chats (but allow customer chats that mention BitSafe)
        if any(
            skip in chat_name.lower()
            for skip in [
                "bitsafe company",
                "bitsafe product",
                "bitsafe bd",
                "bitsafe marketing",
                "internal bitsafe",
            ]
        ):
            continue

        # Try to extract company name (remove BitSafe references, etc.)
        company_name = chat_name
        company_name = re.sub(r"BitSafe.*?<>", "", company_name)
        company_name = re.sub(r"<>.*?BitSafe.*?", "", company_name)
        company_name = re.sub(r"\(.*?\)", "", company_name)
        company_name = company_name.strip()

        # Only include if it looks like a company (not just a person's name)
        if (
            company_name
            and company_name != "BitSafe"
            and len(company_name.split()) <= 3  # Not too long
            and not any(
                person in company_name.lower()
                for person in ["aki", "addie", "mayank", "amy", "kadeem"]
            )
        ):

            mapping_content += f"- **{company_name}** ‚Üí `{chat_id}`\n"
            company_count += 1

    # Write the corrected mapping
    with open("corrected_telegram_mapping.md", "w") as f:
        f.write(mapping_content)

    print(
        f"\nüìù Created corrected mapping with {company_count} actual company conversations"
    )
    return mapping_content


def main():
    """Main function"""
    print("üöÄ Fixing Telegram mapping...")

    # Find customer conversations
    customer_chats = find_customer_conversations()

    print(f"\nüìä Summary:")
    print(f"Total customer conversations found: {len(customer_chats)}")

    # Create corrected mapping
    mapping_content = create_correct_mapping(customer_chats)

    print(f"\n‚úÖ Done! Check 'corrected_telegram_mapping.md' for the fixed mapping")


if __name__ == "__main__":
    main()
